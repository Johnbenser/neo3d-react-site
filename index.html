<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Benser Hand-Controlled Universe</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; overflow: hidden; background: #030712; font-family: Inter, system-ui, Arial, sans-serif; }
    #app { position: fixed; inset: 0; }
    #cam { position: fixed; right: 12px; bottom: 12px; width: 220px; border-radius: 12px; border: 1px solid rgba(255,255,255,.25); opacity: .9; z-index: 10; }
    .hud { position: fixed; left: 12px; top: 12px; z-index: 11; color: #e5e7eb; display: grid; gap: 8px; }
    .chip { background: rgba(10,16,30,.55); border: 1px solid rgba(255,255,255,.2); border-radius: 999px; padding: 8px 12px; font-size: 12px; backdrop-filter: blur(8px); }
    .btn { cursor: pointer; }
  </style>
</head>
<body>
  <div id="app"></div>
  <video id="cam" autoplay playsinline muted></video>

  <div class="hud">
    <div class="chip">ðŸŒŒ Hand-Controlled Universe</div>
    <div id="status" class="chip">Status: Initializing camera...</div>
    <button id="toggleCam" class="chip btn">Hide Camera Preview</button>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
    import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

    const app = document.getElementById('app');
    const videoEl = document.getElementById('cam');
    const statusEl = document.getElementById('status');
    const toggleBtn = document.getElementById('toggleCam');

    // Three.js scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x030712, 8, 45);

    const camera = new THREE.PerspectiveCamera(62, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0x99aaff, 0.45));
    const lightA = new THREE.PointLight(0x67e8f9, 1.5, 80); lightA.position.set(5, 4, 6); scene.add(lightA);
    const lightB = new THREE.PointLight(0xa78bfa, 1.2, 80); lightB.position.set(-6, -2, 5); scene.add(lightB);

    // Galaxy particles
    const count = 5000;
    const positions = new Float32Array(count * 3);
    const base = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      const radius = 3 + Math.random() * 18;
      const angle = Math.random() * Math.PI * 2;
      const spiral = radius * 0.25;
      const x = Math.cos(angle + spiral) * radius;
      const y = (Math.random() - 0.5) * 8;
      const z = Math.sin(angle + spiral) * radius;
      positions[i3] = base[i3] = x;
      positions[i3 + 1] = base[i3 + 1] = y;
      positions[i3 + 2] = base[i3 + 2] = z;
    }

    const starGeo = new THREE.BufferGeometry();
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0x9fb8ff, size: 0.04, transparent: true, opacity: 0.95 });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // Core orb
    const orb = new THREE.Mesh(
      new THREE.IcosahedronGeometry(1.7, 3),
      new THREE.MeshStandardMaterial({ color: 0x6ee7ff, emissive: 0x2ea8ff, emissiveIntensity: 0.6, roughness: 0.3, metalness: 0.7 })
    );
    scene.add(orb);

    // Hand tracking state
    let handDetected = false;
    const hand = { x: 0, y: 0, z: 0, tx: 0, ty: 0, pinch: 0 };

    function onHands(results) {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
        const lm = results.multiHandLandmarks[0];
        const tip = lm[8]; // index tip
        const thumb = lm[4];

        handDetected = true;
        hand.tx = (tip.x - 0.5) * 2;
        hand.ty = (tip.y - 0.5) * 2;
        hand.z = tip.z;

        const dx = tip.x - thumb.x;
        const dy = tip.y - thumb.y;
        const dz = tip.z - thumb.z;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        hand.pinch = Math.max(0, Math.min(1, 1 - dist * 8));

        statusEl.textContent = `Status: Hand detected â€¢ pinch ${hand.pinch.toFixed(2)}`;
      } else {
        handDetected = false;
        statusEl.textContent = 'Status: Show your hand to control the universe';
      }
    }

    const hands = new Hands({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    hands.onResults(onHands);

    const cam = new Camera(videoEl, {
      onFrame: async () => { await hands.send({ image: videoEl }); },
      width: 640,
      height: 480
    });

    try {
      await cam.start();
      statusEl.textContent = 'Status: Camera ready. Move your hand.';
    } catch (e) {
      statusEl.textContent = 'Status: Camera blocked. Allow webcam permission and refresh.';
    }

    toggleBtn.onclick = () => {
      const hidden = videoEl.style.display === 'none';
      videoEl.style.display = hidden ? 'block' : 'none';
      toggleBtn.textContent = hidden ? 'Hide Camera Preview' : 'Show Camera Preview';
    };

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

    const clock = new THREE.Clock();
    function animate() {
      const t = clock.getElapsedTime();

      hand.x += (hand.tx - hand.x) * 0.08;
      hand.y += (hand.ty - hand.y) * 0.08;

      // Camera responds to hand
      camera.position.x = hand.x * 3.2;
      camera.position.y = -hand.y * 2.2;
      camera.lookAt(0, 0, 0);

      // Core reacts
      orb.rotation.x = t * 0.5 + hand.y * 1.2;
      orb.rotation.y = t * 0.8 + hand.x * 1.2;
      const pulse = 1 + Math.sin(t * 2.4) * 0.05 + hand.pinch * 0.35;
      orb.scale.setScalar(pulse);
      orb.material.emissiveIntensity = 0.55 + hand.pinch * 0.9;

      // Galaxy reacts to hand attraction/repulsion
      const pos = starGeo.attributes.position.array;
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const bx = base[i3], by = base[i3 + 1], bz = base[i3 + 2];

        const swirl = Math.sin(t * 0.7 + i * 0.01) * 0.08;
        let x = bx + Math.cos(t * 0.25 + i) * swirl;
        let y = by + Math.sin(t * 0.28 + i * 0.7) * swirl;
        let z = bz + Math.sin(t * 0.22 + i * 1.3) * swirl;

        if (handDetected) {
          const hx = hand.x * 6;
          const hy = -hand.y * 4;
          const hz = 0;
          const dx = x - hx, dy = y - hy, dz = z - hz;
          const d2 = dx * dx + dy * dy + dz * dz + 0.0001;
          const force = (hand.pinch > 0.4 ? -1 : 1) * (0.8 + hand.pinch * 1.6) / d2;
          x += dx * force;
          y += dy * force;
          z += dz * force;
        }

        pos[i3] = x;
        pos[i3 + 1] = y;
        pos[i3 + 2] = z;
      }
      starGeo.attributes.position.needsUpdate = true;

      stars.rotation.y = t * 0.04;
      stars.rotation.x = Math.sin(t * 0.15) * 0.08;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>