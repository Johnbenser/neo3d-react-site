<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Benser Neon Nexus</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: Inter, system-ui, Arial, sans-serif; background: #040612; }
    #app { position: fixed; inset: 0; }
    .ui {
      position: fixed; inset: 0; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 18px;
      color: #e2e8f0;
      background: radial-gradient(circle at 20% 20%, rgba(103,232,249,.08), transparent 35%), radial-gradient(circle at 80% 30%, rgba(167,139,250,.08), transparent 35%);
    }
    .topbar { display: flex; justify-content: space-between; align-items: center; }
    .chip { font-size: 12px; border: 1px solid rgba(255,255,255,.2); border-radius: 999px; padding: 7px 12px; backdrop-filter: blur(6px); background: rgba(10,14,32,.35); }
    .hero { max-width: 760px; margin-bottom: 30px; }
    h1 {
      margin: 0; font-size: clamp(32px, 8vw, 78px); line-height: .95;
      letter-spacing: -0.03em; text-shadow: 0 0 24px rgba(110,231,255,.28);
    }
    p { margin: 14px 0 0; color: #cbd5e1; font-size: clamp(14px, 2.4vw, 20px); }
    .hint { font-size: 12px; opacity: .85; margin-top: 10px; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="ui">
    <div class="topbar">
      <div class="chip">⚡ THREE.JS LIVE EXPERIENCE</div>
      <div class="chip" id="fps">FPS: --</div>
    </div>
    <div class="hero">
      <h1>Benser’s<br/>Neon Nexus</h1>
      <p>Move your cursor / drag on phone. The world bends around you in real-time.</p>
      <div class="hint">Optimized for desktop + mobile • Auto-deployed on your Vercel</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const app = document.getElementById('app');
    const fpsEl = document.getElementById('fps');

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x050712, 6, 28);

    const camera = new THREE.PerspectiveCamera(62, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0.5, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0x88aaff, 0.55);
    scene.add(ambient);

    const key = new THREE.PointLight(0x67e8f9, 1.7, 40);
    key.position.set(3, 3, 4);
    scene.add(key);

    const rim = new THREE.PointLight(0xa78bfa, 1.4, 40);
    rim.position.set(-4, -1, 2);
    scene.add(rim);

    // Main hero mesh
    const heroGeo = new THREE.TorusKnotGeometry(1.6, 0.45, 220, 22);
    const heroMat = new THREE.MeshStandardMaterial({
      color: 0x77f4ff,
      emissive: 0x1b9fcf,
      emissiveIntensity: 0.45,
      metalness: 0.85,
      roughness: 0.25
    });
    const hero = new THREE.Mesh(heroGeo, heroMat);
    scene.add(hero);

    // Orbit rings
    const rings = [];
    for (let i = 0; i < 3; i++) {
      const g = new THREE.TorusGeometry(2.8 + i * 0.5, 0.03, 12, 220);
      const m = new THREE.MeshBasicMaterial({
        color: i % 2 ? 0xa78bfa : 0x67e8f9,
        transparent: true,
        opacity: 0.45
      });
      const ring = new THREE.Mesh(g, m);
      ring.rotation.x = Math.PI * (0.27 + i * 0.08);
      ring.rotation.y = i * 0.7;
      scene.add(ring);
      rings.push(ring);
    }

    // Particle galaxy
    const count = 2200;
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      const r = 5 + Math.random() * 12;
      const a = Math.random() * Math.PI * 2;
      const y = (Math.random() - 0.5) * 8;
      pos[i3] = Math.cos(a) * r;
      pos[i3 + 1] = y;
      pos[i3 + 2] = Math.sin(a) * r;
    }
    const starsGeo = new THREE.BufferGeometry();
    starsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const starsMat = new THREE.PointsMaterial({ color: 0x99b6ff, size: 0.035, transparent: true, opacity: 0.9 });
    const stars = new THREE.Points(starsGeo, starsMat);
    scene.add(stars);

    // Mouse/touch parallax
    const pointer = { x: 0, y: 0, tx: 0, ty: 0 };
    const setPointer = (x, y) => {
      pointer.tx = (x / innerWidth) * 2 - 1;
      pointer.ty = (y / innerHeight) * 2 - 1;
    };
    addEventListener('mousemove', e => setPointer(e.clientX, e.clientY));
    addEventListener('touchmove', e => {
      const t = e.touches[0];
      if (t) setPointer(t.clientX, t.clientY);
    }, { passive: true });

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

    let last = performance.now();
    let frames = 0;
    let fpsClock = 0;

    const clock = new THREE.Clock();
    function animate() {
      const t = clock.getElapsedTime();

      pointer.x += (pointer.tx - pointer.x) * 0.06;
      pointer.y += (pointer.ty - pointer.y) * 0.06;

      camera.position.x = pointer.x * 1.2;
      camera.position.y = 0.5 + -pointer.y * 0.8;
      camera.lookAt(0, 0, 0);

      hero.rotation.x = t * 0.45 + pointer.y * 0.5;
      hero.rotation.y = t * 0.65 + pointer.x * 0.7;
      hero.position.y = Math.sin(t * 1.3) * 0.18;

      rings.forEach((r, i) => {
        r.rotation.z = t * (0.14 + i * 0.06) * (i % 2 ? 1 : -1);
        r.material.opacity = 0.22 + Math.sin(t * 1.4 + i) * 0.12;
      });

      stars.rotation.y = t * 0.03;
      stars.rotation.x = Math.sin(t * 0.12) * 0.08;

      key.position.x = 3 + Math.sin(t * 1.8) * 1.2 + pointer.x;
      rim.position.y = -1 + Math.cos(t * 1.2) * 1.1 - pointer.y;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);

      // FPS meter
      const now = performance.now();
      const dt = now - last;
      last = now;
      fpsClock += dt;
      frames++;
      if (fpsClock >= 400) {
        const fps = Math.round((frames * 1000) / fpsClock);
        fpsEl.textContent = `FPS: ${fps}`;
        fpsClock = 0;
        frames = 0;
      }
    }

    animate();
  </script>
</body>
</html>