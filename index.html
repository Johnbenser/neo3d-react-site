<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Benser Universe Explorer</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: Inter, system-ui, Arial, sans-serif; background: #02040f; color: #e5e7eb; }
    #app { position: fixed; inset: 0; }

    .hud {
      position: fixed;
      inset: 12px 12px auto 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      z-index: 20;
      pointer-events: none;
    }

    .chip {
      pointer-events: auto;
      font-size: 12px;
      background: rgba(8, 14, 30, 0.6);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 999px;
      padding: 8px 12px;
      backdrop-filter: blur(8px);
    }

    .panel {
      position: fixed;
      right: 12px;
      top: 56px;
      width: min(360px, 92vw);
      max-height: calc(100vh - 72px);
      overflow: auto;
      z-index: 20;
      background: rgba(7, 12, 24, 0.76);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 14px;
      padding: 12px;
      backdrop-filter: blur(10px);
    }

    .title { margin: 0 0 6px; font-size: 18px; }
    .desc { margin: 0; font-size: 13px; opacity: .9; line-height: 1.45; }

    .actions { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 8px; }
    button {
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.07);
      color: #e2e8f0;
      border-radius: 999px;
      padding: 7px 11px;
      font-size: 12px;
      cursor: pointer;
    }
    button.primary {
      background: linear-gradient(90deg,#22d3ee,#8b5cf6);
      color: #031122;
      font-weight: 700;
      border: none;
    }

    .planet-list { margin-top: 10px; display: grid; gap: 8px; }
    .planet-item {
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      border-radius: 10px;
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .planet-name { font-size: 13px; font-weight: 700; }
    .planet-sub { font-size: 11px; opacity: .8; }

    .footer { margin-top: 10px; font-size: 11px; opacity: .75; }

    @media (max-width: 900px) {
      .panel {
        left: 12px;
        right: 12px;
        top: auto;
        bottom: 12px;
        width: auto;
        max-height: 42vh;
      }
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div class="chip">ðŸŒŒ Benser Universe Explorer</div>
    <div id="fps" class="chip">FPS: --</div>
  </div>

  <aside class="panel">
    <h2 id="planetTitle" class="title">Select a planet</h2>
    <p id="planetDesc" class="desc">Click a planet or pick from the list to fly there. Drag to orbit, scroll/pinch to zoom in and out.</p>

    <div class="actions">
      <button id="resetCam" class="primary">Reset Camera</button>
      <button id="tourBtn">Auto Tour</button>
    </div>

    <div id="planetList" class="planet-list"></div>
    <div class="footer">Tip: Cursor movement also adds cinematic parallax to camera and starfield.</div>
  </aside>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const app = document.getElementById('app');
    const fpsEl = document.getElementById('fps');
    const planetTitle = document.getElementById('planetTitle');
    const planetDesc = document.getElementById('planetDesc');
    const planetList = document.getElementById('planetList');
    const resetCam = document.getElementById('resetCam');
    const tourBtn = document.getElementById('tourBtn');

    const planetsData = [
      { name:'Mercury', color:0x9ca3af, size:0.35, distance:3.2, speed:0.032, description:'Smallest planet, heavily cratered, and closest to the Sun. It has extreme temperature swings.' },
      { name:'Venus', color:0xf59e0b, size:0.52, distance:4.4, speed:0.025, description:'A dense COâ‚‚ atmosphere and sulfuric clouds make Venus the hottest planet in the Solar System.' },
      { name:'Earth', color:0x3b82f6, size:0.56, distance:5.8, speed:0.020, description:'Our home planet with liquid water oceans, plate tectonics, and a life-supporting atmosphere.' },
      { name:'Mars', color:0xef4444, size:0.46, distance:7.2, speed:0.016, description:'Known as the red planet. It has giant volcanoes, deep canyons, and signs of ancient water.' },
      { name:'Jupiter', color:0xfbbf24, size:1.15, distance:9.6, speed:0.010, description:'The largest planet, a gas giant with strong storms like the Great Red Spot and many moons.' },
      { name:'Saturn', color:0xeab308, size:0.98, distance:12.4, speed:0.008, rings:true, description:'Famous for its spectacular rings made of ice and rock particles orbiting a gas giant core.' },
      { name:'Uranus', color:0x67e8f9, size:0.76, distance:15.2, speed:0.006, description:'An ice giant tilted on its side, giving it unusual seasons and a pale cyan atmosphere.' },
      { name:'Neptune', color:0x2563eb, size:0.74, distance:18.0, speed:0.005, description:'A distant ice giant with powerful winds and deep blue color due to methane in the atmosphere.' }
    ];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x02040f);
    scene.fog = new THREE.Fog(0x02040f, 18, 90);

    const camera = new THREE.PerspectiveCamera(58, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 4, 24);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minDistance = 3;
    controls.maxDistance = 80;
    controls.target.set(0, 0, 0);

    scene.add(new THREE.AmbientLight(0x8899ff, 0.45));
    const sunLight = new THREE.PointLight(0xffe29a, 2.2, 300);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    // Sun
    const sun = new THREE.Mesh(
      new THREE.SphereGeometry(1.6, 40, 28),
      new THREE.MeshStandardMaterial({ color: 0xffd166, emissive: 0xffb703, emissiveIntensity: 1.0, roughness: 0.4, metalness: 0.0 })
    );
    scene.add(sun);

    // Stars
    const starCount = 7000;
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;
      const r = 30 + Math.random() * 120;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random() * 2) - 1);
      starPos[i3] = r * Math.sin(phi) * Math.cos(theta);
      starPos[i3 + 1] = r * Math.cos(phi);
      starPos[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    const starsGeo = new THREE.BufferGeometry();
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starsMat = new THREE.PointsMaterial({ color: 0xb8c6ff, size: 0.06, transparent: true, opacity: 0.95 });
    const stars = new THREE.Points(starsGeo, starsMat);
    scene.add(stars);

    // Planets
    const planets = [];
    const orbitLines = [];

    planetsData.forEach((p, idx) => {
      const g = new THREE.SphereGeometry(p.size, 28, 20);
      const m = new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.7, metalness: 0.1, emissive: p.color, emissiveIntensity: 0.08 });
      const mesh = new THREE.Mesh(g, m);
      mesh.userData = { ...p, idx };
      scene.add(mesh);
      planets.push(mesh);

      const orbitGeo = new THREE.RingGeometry(p.distance - 0.01, p.distance + 0.01, 180);
      const orbitMat = new THREE.MeshBasicMaterial({ color: 0x2b3658, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
      const orbit = new THREE.Mesh(orbitGeo, orbitMat);
      orbit.rotation.x = Math.PI / 2;
      scene.add(orbit);
      orbitLines.push(orbit);

      if (p.rings) {
        const ringGeo = new THREE.RingGeometry(p.size * 1.35, p.size * 2.15, 96);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xfef3c7, side: THREE.DoubleSide, transparent: true, opacity: 0.75 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI * 0.42;
        mesh.add(ring);
      }
    });

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    let focused = null;
    let touring = false;
    let tourIndex = 0;
    let tourTimer = 0;

    const cursor = { x: 0, y: 0, tx: 0, ty: 0 };
    addEventListener('mousemove', (e) => {
      cursor.tx = (e.clientX / innerWidth) * 2 - 1;
      cursor.ty = (e.clientY / innerHeight) * 2 - 1;
    });

    function setInfo(p) {
      planetTitle.textContent = p.name;
      planetDesc.textContent = p.description;
    }

    function flyToPlanet(planet) {
      focused = planet;
      setInfo(planet.userData);
    }

    function buildList() {
      planetList.innerHTML = '';
      planets.forEach((planet) => {
        const row = document.createElement('div');
        row.className = 'planet-item';

        const left = document.createElement('div');
        left.innerHTML = `<div class="planet-name">${planet.userData.name}</div><div class="planet-sub">Distance ${planet.userData.distance.toFixed(1)} AU (scaled)</div>`;

        const btn = document.createElement('button');
        btn.textContent = 'Explore';
        btn.onclick = () => flyToPlanet(planet);

        row.appendChild(left);
        row.appendChild(btn);
        planetList.appendChild(row);
      });
    }

    buildList();

    resetCam.onclick = () => {
      focused = null;
      controls.target.set(0, 0, 0);
      camera.position.set(0, 4, 24);
      setInfo({ name: 'Select a planet', description: 'Click a planet or pick from the list to fly there. Drag to orbit, scroll/pinch to zoom in and out.' });
    };

    tourBtn.onclick = () => {
      touring = !touring;
      tourBtn.textContent = touring ? 'Stop Tour' : 'Auto Tour';
      tourTimer = 0;
    };

    addEventListener('click', (e) => {
      pointer.x = (e.clientX / innerWidth) * 2 - 1;
      pointer.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(planets);
      if (hits.length) flyToPlanet(hits[0].object);
    });

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

    const clock = new THREE.Clock();
    let fpsFrames = 0, fpsAcc = 0, prev = performance.now();

    function animate() {
      const t = clock.getElapsedTime();
      const dt = clock.getDelta();

      cursor.x += (cursor.tx - cursor.x) * 0.05;
      cursor.y += (cursor.ty - cursor.y) * 0.05;

      sun.rotation.y += 0.002;
      sun.material.emissiveIntensity = 0.95 + Math.sin(t * 1.8) * 0.06;

      planets.forEach((planet) => {
        const p = planet.userData;
        const ang = t * p.speed + p.idx * 0.8;
        planet.position.x = Math.cos(ang) * p.distance;
        planet.position.z = Math.sin(ang) * p.distance;
        planet.position.y = Math.sin(t * 0.5 + p.idx) * 0.08;
        planet.rotation.y += 0.01;
      });

      if (touring) {
        tourTimer += dt;
        if (tourTimer > 4.5) {
          tourIndex = (tourIndex + 1) % planets.length;
          flyToPlanet(planets[tourIndex]);
          tourTimer = 0;
        }
      }

      if (focused) {
        const targetPos = focused.position.clone();
        const dir = targetPos.clone().normalize().multiplyScalar(3.2 + focused.userData.size * 2.2);
        const camTarget = targetPos.clone().add(dir).add(new THREE.Vector3(0.9, 0.8, 0.9));

        camera.position.lerp(camTarget, 0.035);
        controls.target.lerp(targetPos, 0.05);
      } else {
        const idleTarget = new THREE.Vector3(cursor.x * 0.8, cursor.y * -0.35, 0);
        controls.target.lerp(idleTarget, 0.04);
        camera.position.x += ((cursor.x * 1.3) - camera.position.x) * 0.01;
        camera.position.y += ((4 + cursor.y * -0.6) - camera.position.y) * 0.01;
      }

      stars.rotation.y = t * 0.01 + cursor.x * 0.02;
      stars.rotation.x = cursor.y * 0.02;

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);

      const now = performance.now();
      fpsAcc += now - prev;
      prev = now;
      fpsFrames++;
      if (fpsAcc > 450) {
        fpsEl.textContent = `FPS: ${Math.round((fpsFrames * 1000) / fpsAcc)}`;
        fpsAcc = 0;
        fpsFrames = 0;
      }
    }

    animate();
  </script>
</body>
</html>