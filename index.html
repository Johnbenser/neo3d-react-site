<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Neon Dash 3D</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      * { box-sizing: border-box; }
      html, body, #root { margin: 0; height: 100%; background: #070b18; font-family: Inter, system-ui, Arial; color: #e5e7eb; }
      .app { height: 100%; display: grid; grid-template-rows: auto 1fr auto; }
      .hud { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; font-weight: 700; background: linear-gradient(180deg, rgba(0,0,0,.6), rgba(0,0,0,0)); position: fixed; inset: 0 0 auto 0; z-index: 5; }
      .game-wrap { position: relative; height: 100%; overflow: hidden; touch-action: none; }
      canvas { width: 100%; height: 100%; display: block; }
      .overlay { position: absolute; inset: 0; display: grid; place-items: center; z-index: 6; padding: 24px; text-align: center; background: radial-gradient(circle at 50% 20%, rgba(24,35,79,.5), rgba(0,0,0,.65)); }
      .card { width: min(460px, 92vw); background: rgba(17,24,39,.75); border: 1px solid rgba(255,255,255,.16); border-radius: 18px; padding: 20px; backdrop-filter: blur(8px); }
      h1 { margin: 0 0 6px; font-size: 1.8rem; }
      .sub { opacity: .88; margin: 0 0 14px; }
      .btn { background: linear-gradient(90deg, #22d3ee, #8b5cf6); color: #041322; font-weight: 800; border: none; border-radius: 12px; padding: 12px 18px; width: 100%; font-size: 1rem; }
      .tips { margin-top: 10px; font-size: .88rem; opacity: .86; line-height: 1.4; }
      .hook { color: #67e8f9; font-weight: 800; }
      .controls { position: fixed; inset: auto 10px 10px 10px; z-index: 5; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
      .pad { background: rgba(17,24,39,.55); border: 1px solid rgba(255,255,255,.18); color: #e5e7eb; border-radius: 12px; padding: 12px; text-align: center; user-select: none; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const LANES = [-1, 0, 1];

      function App() {
        const canvasRef = React.useRef(null);
        const [started, setStarted] = React.useState(false);
        const [gameOver, setGameOver] = React.useState(false);
        const [score, setScore] = React.useState(0);
        const [best, setBest] = React.useState(Number(localStorage.getItem('neon3d_best') || 0));

        const gameRef = React.useRef({
          lane: 1,
          targetLane: 1,
          speed: 0.33,
          obstacles: [],
          coins: [],
          t: 0,
          score: 0,
          raf: 0,
          spawnTimer: 0,
          coinTimer: 0,
          ended: false,
        });

        const startGame = React.useCallback(() => {
          const g = gameRef.current;
          g.lane = 1;
          g.targetLane = 1;
          g.speed = 0.33;
          g.obstacles = [];
          g.coins = [];
          g.t = 0;
          g.score = 0;
          g.spawnTimer = 0;
          g.coinTimer = 0;
          g.ended = false;
          setScore(0);
          setGameOver(false);
          setStarted(true);
        }, []);

        React.useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext('2d');

          const resize = () => {
            const dpr = Math.min(2, window.devicePixelRatio || 1);
            canvas.width = Math.floor(window.innerWidth * dpr);
            canvas.height = Math.floor(window.innerHeight * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          };
          resize();
          window.addEventListener('resize', resize);

          const projectX = (lane, z, w) => {
            const perspective = 1 / (z + 0.25);
            return w / 2 + lane * 140 * perspective;
          };

          const draw = () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const g = gameRef.current;
            g.t += 1;

            ctx.fillStyle = '#070b18';
            ctx.fillRect(0, 0, w, h);

            // stars
            for (let i = 0; i < 45; i++) {
              const x = (i * 117 + g.t * 0.15) % w;
              const y = (i * 57 + (i % 3) * 99) % (h * 0.65);
              ctx.fillStyle = i % 2 ? 'rgba(103,232,249,.6)' : 'rgba(167,139,250,.45)';
              ctx.fillRect(x, y, 2, 2);
            }

            // road/tunnel lines
            for (let z = 1.7; z > 0.08; z -= 0.045) {
              const p = 1 / (z + 0.25);
              const y = h * (0.2 + (1 - p) * 0.85);
              const roadW = 420 * p;
              const alpha = Math.max(0.05, 0.35 * (1 - z / 1.7));
              ctx.strokeStyle = `rgba(34,211,238,${alpha})`;
              ctx.beginPath();
              ctx.moveTo(w / 2 - roadW, y);
              ctx.lineTo(w / 2 + roadW, y);
              ctx.stroke();
            }

            // lane interpolation
            g.lane += (g.targetLane - g.lane) * 0.24;

            // spawn obstacles/coins
            g.spawnTimer -= g.speed;
            g.coinTimer -= g.speed;
            if (g.spawnTimer <= 0) {
              g.spawnTimer = Math.max(26, 55 - g.score * 0.05);
              const lane = Math.floor(Math.random() * 3);
              g.obstacles.push({ lane, z: 1.7 });
            }
            if (g.coinTimer <= 0) {
              g.coinTimer = 24;
              const lane = Math.floor(Math.random() * 3);
              g.coins.push({ lane, z: 1.7 });
            }

            // player
            const playerX = projectX(g.lane - 1, 0.13, w);
            const playerY = h * 0.84;
            const playerW = 64;
            const playerH = 26;
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(playerX - playerW / 2, playerY - playerH / 2, playerW, playerH);
            ctx.fillStyle = '#22d3ee';
            ctx.fillRect(playerX - 12, playerY - 8, 24, 8);

            // update/draw obstacles
            for (const ob of g.obstacles) {
              ob.z -= g.speed * 0.016;
              const x = projectX(ob.lane - 1, ob.z, w);
              const p = 1 / (ob.z + 0.25);
              const size = Math.max(14, 70 * p);
              const y = h * (0.2 + (1 - p) * 0.65);

              ctx.fillStyle = '#fb7185';
              ctx.fillRect(x - size / 2, y - size / 2, size, size);

              const near = ob.z < 0.2;
              if (near && Math.abs(ob.lane - 1 - g.lane) < 0.33) {
                g.ended = true;
              }
            }

            // coins
            for (const c of g.coins) {
              c.z -= g.speed * 0.016;
              const x = projectX(c.lane - 1, c.z, w);
              const p = 1 / (c.z + 0.25);
              const r = Math.max(5, 14 * p);
              const y = h * (0.2 + (1 - p) * 0.65);

              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.fillStyle = '#fde047';
              ctx.fill();

              const near = c.z < 0.2;
              if (near && Math.abs(c.lane - 1 - g.lane) < 0.33) {
                c.hit = true;
                g.score += 10;
              }
            }

            g.obstacles = g.obstacles.filter((o) => o.z > 0);
            g.coins = g.coins.filter((c) => c.z > 0 && !c.hit);

            g.score += 1;
            g.speed = Math.min(0.7, 0.33 + g.score * 0.0007);
            if (g.score % 4 === 0) setScore(g.score);

            if (g.ended) {
              setGameOver(true);
              setStarted(false);
              const bestNow = Math.max(best, g.score);
              if (bestNow !== best) {
                setBest(bestNow);
                localStorage.setItem('neon3d_best', String(bestNow));
              }
              cancelAnimationFrame(g.raf);
              return;
            }

            g.raf = requestAnimationFrame(draw);
          };

          if (started && !gameOver) {
            const g = gameRef.current;
            cancelAnimationFrame(g.raf);
            g.raf = requestAnimationFrame(draw);
          }

          return () => {
            cancelAnimationFrame(gameRef.current.raf);
            window.removeEventListener('resize', resize);
          };
        }, [started, gameOver, best]);

        const moveLeft = () => {
          const g = gameRef.current;
          g.targetLane = Math.max(0, g.targetLane - 1);
        };

        const moveRight = () => {
          const g = gameRef.current;
          g.targetLane = Math.min(2, g.targetLane + 1);
        };

        const handleTouch = (e) => {
          const x = e.touches[0].clientX;
          if (x < window.innerWidth / 2) moveLeft();
          else moveRight();
        };

        React.useEffect(() => {
          const onKey = (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') moveLeft();
            if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') moveRight();
          };
          window.addEventListener('keydown', onKey);
          return () => window.removeEventListener('keydown', onKey);
        }, []);

        return (
          <div className="app">
            <div className="hud">
              <div>⚡ Neon Dash 3D</div>
              <div>Score: {score} • Best: {best}</div>
            </div>

            <div className="game-wrap" onTouchStart={handleTouch}>
              <canvas ref={canvasRef} />

              {(!started || gameOver) && (
                <div className="overlay">
                  <div className="card">
                    <h1>{gameOver ? 'Crashed! Try Again' : '3D Hook Game'}</h1>
                    <p className="sub">
                      <span className="hook">Dodge obstacles, collect coins, beat your best score.</span>
                    </p>
                    <button className="btn" onClick={startGame}>{gameOver ? 'Play Again' : 'Start Game'}</button>
                    <div className="tips">Phone: tap left/right side to move lanes • Desktop: Arrow keys A/D</div>
                  </div>
                </div>
              )}

              {started && (
                <div className="controls">
                  <div className="pad" onTouchStart={moveLeft} onMouseDown={moveLeft}>◀ LEFT</div>
                  <div className="pad" onTouchStart={moveRight} onMouseDown={moveRight}>RIGHT ▶</div>
                </div>
              )}
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>